{
  "rules": [
    {
      "type": "prd",
      "content": "# 교회 청년부 올인원 커뮤니티 MVP PRD\n\n## 1. 배경 및 목표\n대학생·청년부 성도와 소그룹 리더가 분산된 공지·자료·소통 채널을 하나로 통합하고, 교회 인증 기반의 안전한 커뮤니티를 제공하여 참여를 극대화한다.\n\n## 2. 핵심 지표\n- 월간 활성 사용자(MAU): 80명 이상\n- 공지 확인율: 90% 이상\n- 게시판 주간 글/댓글 수: 50건 이상\n\n## 3. Persona\n| Persona | Needs | Pain Points |\n|---|---|---|\n| 청년부 대학생 ‘민준’ | 예배·모임 정보를 한눈에 보고 친구들과 자유 소통 | 카톡방·문서 링크가 흩어져 찾기 힘듦 |\n| 소그룹 리더 ‘지은’ | 일정·자료를 손쉽게 공유하고 멤버 피드백 받기 | 공지 전달 누락, 파일 전송 번거로움 |\n| 사역자 ‘현수 목사’ | 모든 공지·멤버 현황을 한곳에서 관리 | 여러 플랫폼 관리로 업무 과중 |\n\n## 4. 스코프\n### 4.1 MVP 기능 (1차 출시)\n1. **게시판(공지·자유·Q&A)**\n   - 글쓰기, 수정/삭제, 카테고리 필터\n   - 익명·실명 선택 댓글\n2. **캘린더/일정 관리**\n   - 예배·행사·소그룹 일정 등록, 월/주 일람\n   - 일정 상세 페이지 & 알림 연동\n3. **교회 인증 시스템**\n   - 교회 이메일/휴대폰, 관리자의 승인 흐름\n4. **공지 알림**\n   - 웹 푸시(PWA) 및 이메일 알림 발송\n5. **권한/역할**\n   - 일반 사용자, 리더, 관리자 레벨\n\n### 4.2 이후 확장 기능\n- 동호회·소모임 모듈 (게시판+일정)\n- 중고거래 게시판 + 토스 페이먼츠 안전결제\n- 사진·파일 첨부 업로드 개선(멀티 업로드, 썸네일)\n- 관리자 대시보드(통계, 신고 관리)\n- 포인트/뱃지 시스템\n\n## 5. 비-기능 요구사항\n- **모바일 웹(PWA) 우선**: 100명 규모 트래픽 대응\n- Next.js 14 (App Router) + TypeScript\n- Lighthouse PWA 성능 ≥ 90\n- 접근성 WCAG AA 준수\n\n## 6. 일정(예시)\n| Phase | 기간 | 산출물 |\n|---|---|---|\n| 기획·디자인 | 1주 | 와이어프레임, UI Kit |\n| 개발 스프린트 #1 | 2주 | 인증, 게시판 CRUD |\n| 개발 스프린트 #2 | 2주 | 캘린더, 알림, 배포 |\n| 베타 테스트 | 1주 | 피드백 수집 |\n\n## 7. 리스크 & 대응\n- **낮은 초기 참여** → 교회 행사와 연동, 오프라인 홍보\n- **기술 학습 곡선** → Next.js 공식 튜토리얼, Cursor AI pair-programming 활용\n\n## 8. 성공 기준\n- 런칭 1달 내 MAU 목표 달성\n- 공지 확인율 90% 이상\n- 사용자 만족도 설문 평균 4.5/5",
      "writedAt": "2025-08-14T13:07:47.071Z"
    },
    {
      "type": "architecture",
      "content": "# 기술 요구 사항 문서 (TRD)\n\n## 1. 기술 요약\n- **프로젝트 개요**: 교회 청년부 커뮤니티 MVP 개발을 위해 Next.js 14, TypeScript, Vercel, Supabase, TailwindCSS, Shadcn UI, OpenAI API, Toss Payments 기술 스택을 활용하여 웹 기반 PWA를 구축한다. Supabase Auth를 통해 안전한 인증 시스템을 구축하고, Supabase Storage를 사용하여 파일 업로드 및 관리를 처리한다. Supabase Realtime을 통해 실시간 알림 및 데이터 동기화를 구현한다.\n- **핵심 기술 스택**: Next.js 14, TypeScript, Vercel, Supabase, Supabase Auth, Supabase Storage, Supabase Realtime, TailwindCSS, Shadcn UI, OpenAI API, Toss Payments\n- **주요 기술 목표**:\n    - **성능**: Lighthouse PWA 성능 점수 90점 이상 달성\n    - **확장성**: 100명 규모의 트래픽을 안정적으로 처리\n    - **안정성**: 안정적인 서비스 운영 및 데이터 무결성 확보\n- **주요 기술 가정**:\n    - Vercel 플랫폼의 안정적인 호스팅 환경\n    - Supabase 서비스의 안정적인 데이터베이스 및 인증 서비스 제공\n    - 사용자들의 안정적인 인터넷 연결\n\n## 2. 기술 스택\n\n| 범주             | 기술 / 라이브러리       | 사유 (이 프로젝트에 선택된 이유)                                                                                                                                                                                                                                                                                                                |\n| ---------------- | --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| 프레임워크         | Next.js 14            | 서버 사이드 렌더링 (SSR) 및 정적 사이트 생성 (SSG) 기능을 제공하여 초기 로딩 속도 향상 및 SEO 최적화. App Router를 활용하여 효율적인 라우팅 및 코드 분할.                                                                                                                                                                                                |\n| 언어             | TypeScript            | 정적 타입 검사를 통해 코드 안정성 및 유지보수성 향상. 개발 생산성 향상.                                                                                                                                                                                                                                                                         |\n| 호스팅           | Vercel                | Next.js에 최적화된 플랫폼으로, 간편한 배포 및 자동 스케일링 기능 제공. PWA 지원 및 CDN 통합.                                                                                                                                                                                                                                                        |\n| 데이터베이스       | Supabase              | PostgreSQL 기반의 BaaS (Backend as a Service)로, 실시간 데이터베이스, 인증, 스토리지 기능을 제공하여 개발 속도 향상.                                                                                                                                                                                                                              |\n| 인증             | Supabase Auth         | 간편한 인증 및 권한 관리 기능 제공. 소셜 로그인, 이메일/비밀번호 인증 등 다양한 인증 방식 지원.                                                                                                                                                                                                                                                         |\n| 스토리지           | Supabase Storage      | 이미지, 파일 등 정적 자산 저장 및 관리 기능 제공. CDN 통합을 통해 빠른 전송 속도 보장.                                                                                                                                                                                                                                                           |\n| 실시간 통신        | Supabase Realtime     | 실시간 데이터 동기화 및 알림 기능 제공. WebSocket 기반으로 효율적인 통신 구현.                                                                                                                                                                                                                                                                 |\n| UI 프레임워크      | TailwindCSS           | 유틸리티 우선 CSS 프레임워크로, 빠른 UI 개발 및 유지보수 용이. 컴포넌트 재사용성 향상.                                                                                                                                                                                                                                                           |\n| UI 컴포넌트 라이브러리 | Shadcn UI             | 재사용 가능한 UI 컴포넌트 제공. TailwindCSS 기반으로 디자인 일관성 유지.                                                                                                                                                                                                                                                                      |\n| AI API           | OpenAI API            | (이후 확장 기능) 게시글 요약, 댓글 자동 생성 등에 활용 가능.                                                                                                                                                                                                                                                                                          |\n| 결제             | Toss Payments         | (이후 확장 기능) 중고거래 게시판 안전 결제 기능 구현에 사용. 간편 결제 및 다양한 결제 수단 지원.                                                                                                                                                                                                                                                         |\n\n## 3. 시스템 아키텍처 설계\n\n### 최상위 빌딩 블록\n- **Frontend (Next.js)**:\n    - 사용자 인터페이스 및 사용자 경험을 담당합니다.\n    - 컴포넌트 기반 아키텍처로 구성됩니다.\n    - 하위 빌딩 블록: UI 컴포넌트, 페이지 라우팅, 상태 관리\n- **Backend (Supabase)**:\n    - 데이터베이스, 인증, 스토리지, 실시간 통신 기능을 제공합니다.\n    - API 엔드포인트를 통해 Frontend와 통신합니다.\n    - 하위 빌딩 블록: Supabase Auth, Supabase Storage, Supabase Realtime, PostgreSQL 데이터베이스\n- **External APIs (OpenAI, Toss Payments)**:\n    - 외부 서비스와의 연동을 담당합니다.\n    - OpenAI API를 통해 AI 기능을 제공하고, Toss Payments를 통해 결제 기능을 제공합니다.\n    - 하위 빌딩 블록: OpenAI API, Toss Payments API\n\n### 최상위 컴포넌트 상호 작용 다이어그램\n\n```mermaid\ngraph TD\n    A[Frontend (Next.js)] --> B[Backend (Supabase)]\n    B --> C[PostgreSQL Database]\n    B --> D[Supabase Auth]\n    B --> E[Supabase Storage]\n    B --> F[Supabase Realtime]\n    A --> G[OpenAI API]\n    A --> H[Toss Payments API]\n```\n\n- **Frontend (Next.js) -> Backend (Supabase)**: 사용자 요청에 따라 API 호출을 통해 데이터 조회, 생성, 수정, 삭제 작업을 수행합니다.\n- **Backend (Supabase) -> PostgreSQL Database**: 데이터베이스에 데이터를 저장하고 조회합니다.\n- **Backend (Supabase) -> Supabase Auth**: 사용자 인증 및 권한 관리를 처리합니다.\n- **Backend (Supabase) -> Supabase Storage**: 파일 업로드 및 다운로드를 처리합니다.\n- **Backend (Supabase) -> Supabase Realtime**: 실시간 데이터 동기화 및 알림을 처리합니다.\n- **Frontend (Next.js) -> External APIs (OpenAI, Toss Payments)**: 필요에 따라 외부 API를 호출하여 AI 기능 및 결제 기능을 사용합니다.\n\n### 코드 구성 및 규칙\n\n**도메인 기반 구성 전략**\n- **도메인 분리**: 사용자 관리, 게시판, 캘린더, 알림 등 비즈니스 도메인별로 코드를 분리합니다.\n- **계층 기반 아키텍처**: 프레젠테이션 계층, 비즈니스 로직 계층, 데이터 접근 계층, 인프라 계층으로 분리합니다.\n- **기능 기반 모듈**: 관련 기능을 함께 그룹화하여 모듈을 구성합니다.\n- **공유 컴포넌트**: 공통 유틸리티, 타입, 재사용 가능한 컴포넌트를 별도의 모듈로 분리합니다.\n\n**범용 파일 및 폴더 구조**\n```\n/\n├── components/             # 재사용 가능한 UI 컴포넌트\n│   ├── Button.tsx\n│   ├── Card.tsx\n│   └── ...\n├── pages/                  # Next.js 페이지 (라우팅)\n│   ├── _app.tsx           # 전역 레이아웃 및 설정\n│   ├── index.tsx          # 홈 페이지\n│   ├── board/\n│   │   ├── [id].tsx      # 게시글 상세 페이지\n│   │   └── write.tsx     # 게시글 작성 페이지\n│   ├── calendar.tsx       # 캘린더 페이지\n│   └── ...\n├── utils/                  # 유틸리티 함수\n│   ├── api.ts             # API 호출 함수\n│   ├── date.ts            # 날짜 관련 함수\n│   └── ...\n├── types/                  # TypeScript 타입 정의\n│   ├── Board.ts\n│   ├── User.ts\n│   └── ...\n├── public/                 # 정적 자산 (이미지, 폰트 등)\n│   ├── images/\n│   ├── fonts/\n│   └── ...\n├── styles/                 # 전역 스타일\n│   ├── globals.css\n│   └── ...\n├── .env.local              # 환경 변수\n├── next.config.js          # Next.js 설정 파일\n└── tsconfig.json           # TypeScript 설정 파일\n```\n\n### 데이터 흐름 및 통신 패턴\n- **클라이언트-서버 통신**: API 요청/응답 패턴을 사용합니다.\n- **데이터베이스 상호 작용**: Supabase 클라이언트를 사용하여 데이터베이스와 상호 작용합니다.\n- **외부 서비스 통합**: third-party API를 통합합니다.\n- **실시간 통신**: Supabase Realtime을 사용하여 실시간 통신을 구현합니다.\n- **데이터 동기화**: 분산된 컴포넌트 간의 일관성 패턴을 사용합니다.\n\n## 4. 성능 및 최적화 전략\n- **코드 분할**: Next.js의 Dynamic Import를 사용하여 초기 로딩 속도를 최적화합니다.\n- **이미지 최적화**: Next.js의 Image 컴포넌트를 사용하여 이미지 크기 및 형식을 최적화합니다.\n- **캐싱**: Vercel의 CDN을 사용하여 정적 자산을 캐싱합니다.\n- **데이터베이스 쿼리 최적화**: 필요한 데이터만 조회하도록 쿼리를 최적화합니다.\n\n## 5. 구현 로드맵 및 마일스톤\n### 1단계: 기초 (MVP 구현)\n- **핵심 인프라**: 기본 시스템 설정 및 기초 컴포넌트 구현\n- **필수 기능**: 최소 실행 가능 제품 기능 구현 (게시판 CRUD, 캘린더, 인증)\n- **기본 보안**: 기본적인 보안 구현 (Supabase Auth)\n- **개발 환경**: 개발 환경 설정 및 CI/CD 기본 설정\n- **일정**: 2주\n\n### 2단계: 기능 개선\n- **고급 기능**: MVP 이상의 확장 기능 구현 (알림, 권한/역할)\n- **성능 최적화**: 시스템 성능 개선\n- **보안 강화**: 고급 보안 기능 및 규정 준수 구현\n- **모니터링 구현**: 포괄적인 관찰 가능성 설정\n- **일정**: 2주\n\n## 6. 위험 평가 및 완화 전략\n### 기술적 위험 분석\n- **기술 위험**: 잠재적인 기술 문제 및 복잡성 문제\n- **성능 위험**: 확장성 및 성능 병목 현상 문제\n- **보안 위험**: 잠재적인 보안 취약점 및 공격 벡터\n- **통합 위험**: third-party 서비스 종속성 및 실패 지점\n- **완화 전략**: 각 식별된 위험을 해결하기 위한 구체적인 접근 방식\n\n### 프로젝트 전달 위험\n- **일정 위험**: 개발 일정 문제 및 종속성\n- **리소스 위험**: 팀 역량 및 기술 전문성 요구 사항\n- **품질 위험**: 코드 품질 및 테스트 범위 문제\n- **배포 위험**: 프로덕션 배포 및 환경 문제\n- **비상 계획**: 대체 접근 방식 및 백업 전략\n",
      "writedAt": "2025-08-14T13:07:47.071Z"
    },
    {
      "type": "guideline",
      "content": "# Code Guideline\n\n## 1. Project Overview\n\nThis document outlines the coding standards for the Church Youth Group Community MVP project, a web-based PWA built with Next.js 14, TypeScript, Vercel, Supabase, TailwindCSS, and Shadcn UI. The project aims to consolidate communication channels for students and young adults, providing a secure, church-authenticated community platform. Key architectural decisions include using Next.js for SSR and SSG, Supabase for backend services (database, auth, storage, realtime), and TailwindCSS with Shadcn UI for rapid UI development.\n\n## 2. Core Principles\n\n- **Maintainability**: Code should be easy to understand, modify, and debug by any team member.\n- **Readability**: Code should be clear, concise, and well-documented to facilitate understanding.\n- **Testability**: Code should be designed to be easily tested at the unit and integration levels.\n- **Performance**: Code should be optimized for speed and efficiency, minimizing resource consumption.\n- **Security**: Code should be written with security in mind, preventing common vulnerabilities.\n\n## 3. Language-Specific Guidelines\n\n### 3.1. TypeScript\n\n#### File Organization and Directory Structure\n\n- Group related files into directories based on feature or domain (e.g., `components/Board`, `utils/date`).\n- Use descriptive file names (e.g., `Button.tsx`, `api.ts`).\n- Follow the project's overall directory structure as defined in the TRD.\n\n#### Import/Dependency Management\n\n- Use absolute imports for internal modules to improve readability and prevent issues with relative paths.\n- Use named imports whenever possible to explicitly declare what is being imported.\n- Keep dependencies up-to-date and regularly audit for security vulnerabilities.\n\n#### Error Handling Patterns\n\n- Use `try...catch` blocks for handling potential errors, especially in asynchronous operations.\n- Create custom error classes for specific error scenarios to provide more context.\n- Log errors with sufficient detail for debugging purposes.\n- Handle errors gracefully and provide informative messages to the user.\n\n```typescript\n// MUST: Example of error handling with try...catch and custom error\nclass ApiError extends Error {\n  constructor(message: string, public statusCode: number) {\n    super(message);\n    this.name = \"ApiError\";\n  }\n}\n\nasync function fetchData(url: string): Promise<any> {\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new ApiError(`Failed to fetch data: ${response.statusText}`, response.status);\n    }\n    return await response.json();\n  } catch (error: any) {\n    console.error(\"Error fetching data:\", error);\n    throw error; // Re-throw to allow the caller to handle it\n  }\n}\n```\n\n### 3.2. Next.js\n\n#### File Organization and Directory Structure\n\n- Utilize the `app` directory structure for routing and components.\n- Organize components based on features or domains.\n- Place API routes in the `app/api` directory.\n- Use the `public` directory for static assets.\n\n#### Import/Dependency Management\n\n- Use Next.js's built-in module resolution for internal modules.\n- Use dynamic imports (`next/dynamic`) for code splitting and lazy loading.\n- Manage environment variables using `.env.local` and `next.config.js`.\n\n#### Error Handling Patterns\n\n- Implement error boundaries using React's `ErrorBoundary` component to catch errors in components.\n- Use Next.js's custom error page (`app/error.js`) to handle unhandled errors.\n- Handle API route errors by sending appropriate HTTP status codes and error messages.\n\n```typescript\n// MUST: Example of using an ErrorBoundary component\n\"use client\";\n\nimport React, { useState, useEffect } from 'react';\n\ninterface Props {\n  children: React.ReactNode;\n}\n\ninterface State {\n  hasError: boolean;\n}\n\nclass ErrorBoundary extends React.Component<Props, State> {\n  constructor(props: Props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error: any) {\n    // Update state so the next render will show the fallback UI.\n    return { hasError: true };\n  }\n\n  componentDidCatch(error: any, errorInfo: any) {\n    // You can also log the error to an error reporting service\n    console.error(\"Captured an error\", error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // You can render any custom fallback UI\n      return <h1>Something went wrong.</h1>;\n    }\n\n    return this.props.children;\n  }\n}\n\nexport default ErrorBoundary;\n```\n\n### 3.3. TailwindCSS\n\n#### File Organization and Directory Structure\n\n- Use a `styles` directory for global CSS files and custom styles.\n- Utilize Tailwind's configuration file (`tailwind.config.js`) for customization.\n- Keep component-specific styles within the component files.\n\n#### Class Naming Conventions\n\n- Use descriptive class names that follow a consistent pattern.\n- Avoid overly long or complex class names.\n- Utilize Tailwind's utility classes for styling.\n- Group related classes together for readability.\n\n#### Usage Patterns\n\n- Use Tailwind's `@apply` directive sparingly to avoid creating overly specific styles.\n- Utilize Tailwind's theme configuration for consistent colors, fonts, and spacing.\n- Use responsive modifiers (e.g., `md:`, `lg:`) for responsive design.\n\n### 3.4. Supabase\n\n#### Data Modeling\n\n- Define clear and consistent data models in Supabase.\n- Use appropriate data types for each field.\n- Establish relationships between tables using foreign keys.\n\n#### Querying\n\n- Use Supabase's client library for querying the database.\n- Optimize queries to retrieve only the necessary data.\n- Use indexes to improve query performance.\n\n#### Security\n\n- Implement row-level security (RLS) policies to control access to data.\n- Use Supabase Auth for authentication and authorization.\n- Sanitize user input to prevent SQL injection attacks.\n\n```typescript\n// MUST: Example of using Supabase RLS policies\n// Assuming you have a table named 'posts'\n// Allow authenticated users to read all posts\n// Allow users to create posts with their own user_id\n// Allow users to update/delete their own posts\n\n// Create policy for SELECT\ncreate policy \"Enable read access for all users\"\non posts\nfor select\nusing (true);\n\n// Create policy for INSERT\ncreate policy \"Enable insert for authenticated users based on user_id\"\non posts\nfor insert\nwith check (auth.uid() = user_id);\n\n// Create policy for UPDATE\ncreate policy \"Enable update for users based on user_id\"\non posts\nfor update\nwith check (auth.uid() = user_id);\n\n// Create policy for DELETE\ncreate policy \"Enable delete for users based on user_id\"\non posts\nfor delete\nwith check (auth.uid() = user_id);\n```\n\n## 4. Code Style Rules\n\n### MUST Follow:\n\n- **Consistent Formatting**: Use Prettier to automatically format code according to a consistent style.\n  - Rationale: Ensures code readability and reduces stylistic disagreements.\n- **Descriptive Naming**: Use clear and descriptive names for variables, functions, and classes.\n  - Rationale: Improves code understanding and maintainability.\n- **Concise Functions**: Keep functions short and focused, ideally performing a single, well-defined task.\n  - Rationale: Enhances code readability and testability.\n- **Meaningful Comments**: Add comments to explain complex logic or non-obvious code sections.\n  - Rationale: Helps other developers understand the code's purpose and functionality.\n- **Type Annotations**: Use TypeScript's type annotations extensively to define the types of variables, function parameters, and return values.\n  - Rationale: Improves code safety and prevents runtime errors.\n- **Error handling**: Implement robust error handling using `try...catch` blocks and custom error classes.\n  - Rationale: Prevents application crashes and provides informative error messages.\n- **Avoid Magic Numbers**: Use named constants instead of hardcoding numerical values.\n  - Rationale: Improves code readability and maintainability.\n- **Use environment variables**: Sensitive information like API keys and database credentials should be stored as environment variables, not hardcoded in the application.\n  - Rationale: Increases the security of the application.\n\n### MUST NOT Do:\n\n- **Global Variables**: Avoid using global variables as they can lead to naming conflicts and unpredictable behavior.\n  - Rationale: Promotes modularity and prevents unintended side effects.\n- **Nested Callbacks**: Avoid deeply nested callbacks, which can make code difficult to read and maintain (callback hell). Use Promises or async/await instead.\n  - Rationale: Improves code readability and maintainability.\n- **Ignoring Errors**: Never ignore errors or exceptions without handling them properly.\n  - Rationale: Prevents application crashes and ensures data integrity.\n- **Over-commenting**: Avoid adding excessive comments that state the obvious.\n  - Rationale: Reduces clutter and improves code readability.\n- **Duplicated Code**: Avoid duplicating code. Extract common logic into reusable functions or components.\n  - Rationale: Improves code maintainability and reduces the risk of errors.\n- **Complex conditional statements**: Avoid writing overly complex and nested conditional statements. Simplify them by using helper functions or breaking them down into smaller, more manageable parts.\n  - Rationale: Improves code readability and maintainability.\n- **Committing secrets to repository**: Never commit sensitive information such as API keys, passwords, or database credentials to the repository.\n  - Rationale: Prevents unauthorized access to sensitive information.\n- **Large, Single-Responsibility Files**: Avoid creating massive files with multiple responsibilities. Break down code into smaller, more focused modules.\n  - Rationale: Increases maintainability and reduces complexity.\n\n## 5. Architecture Patterns\n\n### Component/Module Structure Guidelines\n\n- **Atomic Design**: Structure UI components using the Atomic Design methodology (Atoms, Molecules, Organisms, Templates, Pages).\n  - Atoms: Basic UI elements (e.g., buttons, inputs, labels).\n  - Molecules: Combinations of Atoms (e.g., search bar, form field).\n  - Organisms: Combinations of Molecules and Atoms (e.g., header, footer).\n  - Templates: Page layouts with placeholder content.\n  - Pages: Specific instances of Templates with actual content.\n- **Domain-Driven Design**: Organize modules based on business domains (e.g., `board`, `calendar`, `auth`).\n- **Single Responsibility Principle**: Each component/module should have a single, well-defined purpose.\n\n```typescript\n// MUST: Example of Atomic Design component structure (Atom)\n// components/atoms/Button.tsx\n\nimport React from 'react';\n\ninterface ButtonProps {\n  children: React.ReactNode;\n  onClick: () => void;\n  className?: string;\n}\n\nconst Button: React.FC<ButtonProps> = ({ children, onClick, className }) => {\n  return (\n    <button className={`bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded ${className}`} onClick={onClick}>\n      {children}\n    </button>\n  );\n};\n\nexport default Button;\n```\n\n### Data Flow Patterns\n\n- **Unidirectional Data Flow**: Data should flow in one direction, typically from parent components to child components via props.\n- **State Management**: Use React's built-in state management (`useState`, `useContext`) for simple state. For more complex state management, consider using a library like Zustand.\n- **API Communication**: Use a dedicated API client (e.g., `utils/api.ts`) to handle communication with the Supabase backend.\n\n### State Management Conventions\n\n- **Local State**: Use `useState` for component-specific state that doesn't need to be shared.\n- **Context API**: Use `useContext` for sharing state between components within a specific subtree.\n- **Global State**: Use Zustand for managing application-wide state.\n\n### API Design Standards\n\n- **RESTful APIs**: Design APIs following RESTful principles.\n- **Consistent Endpoints**: Use consistent naming conventions for API endpoints.\n- **JSON Format**: Use JSON for request and response bodies.\n- **Error Handling**: Return appropriate HTTP status codes for errors.\n- **Authentication**: Use Supabase Auth for authenticating API requests.\n- **Authorization**: Implement authorization checks to ensure that users have the necessary permissions to access resources.\n\n```typescript\n// MUST: Example of a RESTful API endpoint (Next.js API route)\n// app/api/posts/[id]/route.ts\n\nimport { NextResponse } from 'next/server';\nimport { supabase } from '@/utils/supabaseClient';\n\nexport async function GET(request: Request, { params }: { params: { id: string } }) {\n  const { id } = params;\n\n  const { data, error } = await supabase\n    .from('posts')\n    .select('*')\n    .eq('id', id)\n    .single();\n\n  if (error) {\n    console.error(\"Error fetching post:\", error);\n    return NextResponse.json({ error: error.message }, { status: 500 });\n  }\n\n  if (!data) {\n    return NextResponse.json({ error: 'Post not found' }, { status: 404 });\n  }\n\n  return NextResponse.json(data);\n}\n```\n",
      "writedAt": "2025-08-14T13:07:47.071Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-08-14T13:07:47.071Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-08-14T13:07:47.071Z"
    }
  ]
}